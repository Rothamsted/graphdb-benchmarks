g.V().hasLabel ( 'Concept:Gene:Resource' )
  .out ( 'enc' ).hasLabel ( 'Concept:Protein:Resource' )

  .emit ()
  .repeat ( both ( 'h_s_s', 'ortho', 'xref' ).simplePath().hasLabel ( 'Concept:Protein:Resource' ) )
  .times ( 3 )
  
  .both ( 'is_a', 'ac_by' ).hasLabel ( 'Concept:Enzyme:Resource' )
  .out ( 'ac_by', 'in_by' ).hasLabel ( 'Comp:Concept:Resource' )
  .out ( 'cs_by', 'pd_by' ).hasLabel ( 'Concept:Resource:Transport' )
  
  .repeat ( out ( 'part_of' ).simplePath().hasLabel ( 'Concept:Path:Resource' ) )
  .emit ()
  .times ( 3 )


  .repeat ( in ( 'part_of' ).simplePath ().hasLabel ( 'Concept:Reaction:Resource' ) )
  .emit ()
  .times ( 3 )

  // Go back to other proteins in this reaction
  // optional() is to achieve the same behaviour as in the Cypher and SPARQL queries
  
  .optional (
    emit ()
    .repeat ( __.in ( 'cs_by', 'pd_by' ).simplePath ().hasLabel ( 'Concept:Protein:Resource' ) )
    .times ( 3 )
    
    .emit ()
    .repeat ( both ( 'h_s_s', 'ortho', 'xref' ).simplePath ().hasLabel ( 'Concept:Protein:Resource' ) )
    .times ( 2 )
    
    .optional ( __.in ( 'enc' ) ) // Gene
  ) 
  
.path ().by ( 'iri' )
.sample ( 100 )
